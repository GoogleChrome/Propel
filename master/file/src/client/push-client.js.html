<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <base data-ice="baseUrl" href="../../../">
  <title data-ice="title">src/client/push-client.js | API Document</title>
  <link type="text/css" rel="stylesheet" href="css/style.css">
  <link type="text/css" rel="stylesheet" href="css/prettify-tomorrow.css">
  <script src="script/prettify/prettify.js"></script>
  
  
  <script src="script/manual.js"></script>
</head>
<body class="layout-container" data-ice="rootContainer">

<header>
  <a href="./">Home</a>
  <a href="./manual/index.html" data-ice="manualHeaderLink">Manual</a>
  <a href="identifiers.html">Reference</a>
  <a href="source.html">Source</a>
  
  
  <div class="search-box">
  <span>
    <img src="./image/search.png">
    <span class="search-input-edge"></span><input class="search-input"><span class="search-input-edge"></span>
  </span>
    <ul class="search-result"></ul>
  </div>
</header>

<nav class="navigation" data-ice="nav"><div>
  <ul>
    
  <li data-ice="doc"><div data-ice="dirPath" class="nav-dir-path">client</div><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/client/event-dispatch.js~EventDispatch.html">EventDispatch</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/client/push-client-event.js~PushClientEvent.html">PushClientEvent</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/client/push-client.js~PushClient.html">PushClient</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/client/subscription-failed-error.js~SubscriptionFailedError.html">SubscriptionFailedError</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-serverUpdater">serverUpdater</a></span></span></li>
<li data-ice="doc"><div data-ice="dirPath" class="nav-dir-path">worker</div><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/worker/push-worker.js~PushWorker.html">PushWorker</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-notificationHandler">notificationHandler</a></span></span></li>
</ul>
</div>
</nav>

<div class="content" data-ice="content"><h1 data-ice="title">src/client/push-client.js</h1>
<pre class="source-code line-number raw-source-code"><code class="prettyprint linenums" data-ice="content">/*
  Copyright 2015 Google Inc. All Rights Reserved.
  Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at
      http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
*/
/* eslint-env browser */

import SubscriptionFailedError from &apos;./subscription-failed-error&apos;;
import PushClientEvent from &apos;./push-client-event&apos;;
import EventDispatch from &apos;./event-dispatch&apos;;

const SUPPORTED = &apos;serviceWorker&apos; in navigator &amp;&amp;
    &apos;PushManager&apos; in window &amp;&amp;
    &apos;Notification&apos; in window &amp;&amp;
    &apos;showNotification&apos; in ServiceWorkerRegistration.prototype;

const ERROR_MESSAGES = {
  &apos;bad factory&apos;: &apos;The PushClient.createClient() method expects a service &apos; +
    &apos;worker path and an option scope string.&apos;,
  &apos;bad constructor&apos;: &apos;The PushClient constructor expects a service &apos; +
    &apos;worker registration. Alternatively, you can use &apos; +
    &apos;PropelClient.createClient() to create a PropelClient with a service &apos; +
    &apos;worker path string and an optional scope string.&apos;,
  &apos;redundant worker&apos;: &apos;Worker became redundant&apos;
};

const registrationReady = function(registration) {
  if (registration.active) {
    return Promise.resolve(registration);
  }

  let serviceWorker = registration.installing || registration.waiting;

  return new Promise(function(resolve, reject) {
    // Because the Promise function is called on next tick there is a
    // small chance that the worker became active already.
    if (serviceWorker.state === &apos;activated&apos;) {
      resolve(registration);
      return;
    }

    let stateChangeListener = function() {
      if (serviceWorker.state === &apos;activated&apos;) {
        resolve(registration);
      } else if (serviceWorker.state === &apos;redundant&apos;) {
        reject(new Error(ERROR_MESSAGES[&apos;redundant worker&apos;]));
      } else {
        return;
      }
      serviceWorker.removeEventListener(&apos;statechange&apos;, stateChangeListener);
    };
    serviceWorker.addEventListener(&apos;statechange&apos;, stateChangeListener);
  });
};

/**
 * PushClient is a front end library that simplifies adding push to your
 * site.
 */
export default class PushClient extends EventDispatch {
  /**
   * Constructs a new PushClient.
   *
   * If the current browser has a push subscription then it will be
   * obtained in the constructor and a subscriptionChange event will be
   * dispatched.
   *
   * @param {ServiceWorkerRegistration} registration - Registration of a
   *  service worker to be used for push messages
   */
  constructor(registration) {
    super();

    if (!PushClient.isSupported()) {
      throw new Error(&apos;Your browser does not support the web push API&apos;);
    }

    if (!(registration instanceof ServiceWorkerRegistration)) {
      throw new Error(ERROR_MESSAGES[&apos;bad constructor&apos;]);
    }

    this._registration = registration;

    // It is possible for the subscription to change in between page loads. We
    // should re-send the existing subscription when we initialise (if there is
    // one)
    this._dispatchStatusUpdate();
  }

  _dispatchStatusUpdate() {
    return Promise.all([
      this.getSubscription().catch(() =&gt; {
        return null;
      }),
      PushClient.getPermissionState()
    ])
    .then(results =&gt; {
      return {
        isSubscribed: (results[0] !== null),
        currentSubscription: results[0],
        permissionState: results[1]
      };
    })
    .then(status =&gt; {
      this.dispatchEvent(new PushClientEvent(&apos;statuschange&apos;, status));
    })
    .catch(err =&gt; {
      console.warn(&apos;Unable to dispatch a status event &apos; +
        &apos;getSubscription() failed.&apos;, err);
    });
  }

  /**
   * This method will subscribe a use for push messaging.
   *
   * If permission isn&apos;t granted for push, this method will show the
   * permissions dialog before attempting to subscribe the user to push.
   *
   * @return {Promise&lt;PushSubscription&gt;} A Promise that
   *  resolves with a PushSubscription if successful.
   */
  subscribe() {
    // Check for permission
    return this.requestPermission(false)
    .then(permissionStatus =&gt; {
      if (permissionStatus !== &apos;granted&apos;) {
        this._dispatchStatusUpdate();
        throw new SubscriptionFailedError(permissionStatus);
      }

      this.dispatchEvent(new PushClientEvent(&apos;requestingsubscription&apos;));

      // Make sure we have a service worker and subscribe for push
      return this._registration;
    })
    .then(registrationReady)
    .then(registration =&gt; {
      return registration.pushManager.subscribe({userVisibleOnly: true})
      .catch(err =&gt; {
        return this._dispatchStatusUpdate()
        .then(() =&gt; {
          // This is provide a more helpful message when work with Chrome + GCM
          if (err.message === &apos;Registration failed - no sender id provided&apos;) {
            throw new SubscriptionFailedError(&apos;nogcmid&apos;);
          } else {
            throw err;
          }
        });
      });
    })
    .then(subscription =&gt; {
      this._dispatchStatusUpdate();

      return subscription;
    });
  }

  /**
   * This method will unsubscribe the user from push on the client side.
   *
   * @return {Promise} A Promise that
   *  resolves once the user is unsubscribed.
   */
  unsubscribe() {
    return this.getRegistration()
    .then(registration =&gt; {
      if (registration) {
        return registration.pushManager.getSubscription();
      }
    })
    .then(subscription =&gt; {
      if (subscription) {
        return subscription.unsubscribe();
      }
    })
    .then(() =&gt; {
      this._dispatchStatusUpdate();
    })
    .catch(err =&gt; {
      return this._dispatchStatusUpdate()
      .then(() =&gt; {
        throw err;
      });
    });
  }

  /**
   * Get the registration of the service worker being used for push.
   *
   * @return {Promise&lt;ServiceWorkerRegistration&gt;} A Promise that
   *  resolves to either a ServiceWorkerRegistration.
   */
  getRegistration() {
    return Promise.resolve(this._registration);
  }

  /**
   * If the user is currently subscribed for push then the returned promise will
   * resolve with a PushSubscription object, otherwise it will resolve to null.
   *
   * This will not display the permission dialog.
   *
   * @return {Promise&lt;PushSubscription&gt;} A Promise that resolves with
   *  a PushSubscription or null.
   */
  getSubscription() {
    return this.getRegistration()
    .then(registration =&gt; {
      if (!registration) {
        return null;
      }

      return registration.pushManager.getSubscription();
    });
  }

  /**
   * Will manage requesting permission for push messages, resolving
   * with the final permission status.
   * @param {Boolean} dispatchStatusChange - Optional parameter with a
   * default value of true. If true, a `statuschange` event will be
   * dispatched once the permission state has resolved (i.e. use interacted
   * with the permission dialog).
   * @return {Promise&lt;String&gt;} Permission status of granted, default or denied
   */
  requestPermission(dispatchStatusChange = true) {
    return PushClient.getPermissionState()
    .then(permissionState =&gt; {
      // Check if requesting permission will show a prompt
      if (permissionState === &apos;default&apos;) {
        this.dispatchEvent(new PushClientEvent(&apos;requestingpermission&apos;));
      }

      return new Promise(resolve =&gt; Notification.requestPermission(resolve))
      .then(resolvedState =&gt; {
        if (dispatchStatusChange) {
          this._dispatchStatusUpdate();
        }
        return resolvedState;
      });
    });
  }

  /**
   * If you want a quick way to create Propel Client this factory method
   * just takes a service worker file path and optional scope and
   * returns promise that resolves to a PropelClient or errors if there
   * was a problem.
   * @param {String} swPath - This needs to be the path of a service worker
   * that will be used to handle push messages,
   * @param {String} scope - Optional parameter that can be used to define
   * the scope of a service worker.
   * @return {Promise&lt;PropelClient&gt;} Resolves if the service worker could be
   * registered successfully
   */
  static createClient(swPath, scope) {
    if (!swPath || typeof swPath !== &apos;string&apos; || swPath.length === 0) {
      return Promise.reject(new Error(ERROR_MESSAGES[&apos;bad factory&apos;]));
    }

    let options;
    if (scope) {
      options = {scope};
    }
    return navigator.serviceWorker.register(swPath, options)
    .then(reg =&gt; {
      return new PushClient(reg);
    });
  }

  static isSupported() {
    return SUPPORTED;
  }

  /**
   * This method can be used to check if subscribing the user will display
   * the permission dialog or not.
   * @return {Promise&lt;PermissionStatus&gt;} PermistionStatus will be
   * &apos;granted&apos;, &apos;denied&apos; or &apos;default&apos; to reflect the current permission state
   */
  static getPermissionState() {
    return new Promise(resolve =&gt; {
      resolve(Notification.permission);
    });
  }
}
</code></pre>

</div>

<footer class="footer">
  Generated by <a href="https://esdoc.org">ESDoc<span data-ice="esdocVersion">(0.4.6)</span></a>
</footer>

<script src="script/search_index.js"></script>
<script src="script/search.js"></script>
<script src="script/pretty-print.js"></script>
<script src="script/inherited-summary.js"></script>
<script src="script/test-summary.js"></script>
<script src="script/inner-link.js"></script>
<script src="script/patch-for-local.js"></script>
</body>
</html>
